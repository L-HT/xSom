# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

calculateDelta <- function(inputMatrix, inputVector, naExist, resultDelta) {
    invisible(.Call('xSom_calculateDelta', PACKAGE = 'xSom', inputMatrix, inputVector, naExist, resultDelta))
}

calculateEuclidianDistances <- function(deltaMatrix, oldColumns, resultEuclidianDistances2) {
    .Call('xSom_calculateEuclidianDistances', PACKAGE = 'xSom', deltaMatrix, oldColumns, resultEuclidianDistances2)
}

calculateNeighborhoodTable <- function(somSize, radius) {
    .Call('xSom_calculateNeighborhoodTable', PACKAGE = 'xSom', somSize, radius)
}

tableToCodebookMatrix <- function(somSize, winnerNeuronR, xDim, lookupTable) {
    .Call('xSom_tableToCodebookMatrix', PACKAGE = 'xSom', somSize, winnerNeuronR, xDim, lookupTable)
}

calculateNeighborhoodMatrix <- function(winnerNeuronR, somSize, radius) {
    .Call('xSom_calculateNeighborhoodMatrix', PACKAGE = 'xSom', winnerNeuronR, somSize, radius)
}

matrixToCodebookMatrix <- function(matrix, xDim, result) {
    .Call('xSom_matrixToCodebookMatrix', PACKAGE = 'xSom', matrix, xDim, result)
}

#'
#' Determine the Best Matching Unit (BMU) for a data vector
#'
#' This function takes a vector \code{x} and determines the row of the weight matrix which
#' minimizes the euclidian distance.
#' @param weightMatrix The weight matrix (codebook matrix).
#' @param x The vector.
#' @param oldColumns A boolean vector specifying the columns of the data vector which were already
#' available before the data set has been extended. In other words, the only
#' these columns are used for the calculation of the euclidian distance (for the BMU)
#' while the other other columns are ignored during this step.
#'
#' @return A list containing the following elements: The number of the row which is closest
#' to \code{x}, the x-coordinate and the y-coordinate of the found neuron in the quadratic
#' SOM grid.
#'
#' @export
findWinningNeuron <- function(weightMatrix, x, oldColumns) {
    .Call('xSom_findWinningNeuron', PACKAGE = 'xSom', weightMatrix, x, oldColumns)
}

learnCyclesExtended <- function(dataSet, weightMatrix, oldColumns, cycles = 1L, initLearnRate = 0.01, learnRateReduction = 0.0, initRadius = 1.0, radiusReduction = -1.0, normType = 2L, sampling = 1L, naExist = TRUE, updateParametersPerEpoch = TRUE) {
    .Call('xSom_learnCyclesExtended', PACKAGE = 'xSom', dataSet, weightMatrix, oldColumns, cycles, initLearnRate, learnRateReduction, initRadius, radiusReduction, normType, sampling, naExist, updateParametersPerEpoch)
}

#' A SOM algorithm that handles NA values.
#'
#' If the argument \code{naExist} is set to \code{FALSE}, the first 100 lines of the data set will be
#' scanned for NA values. Depending on whether NA values are found slightly different
#' SOM algorithms are executed:
#' If NA values exist, the algorithm will ignore these values during the calculation of the
#' Best Matching Unit (BMU). If no NA values exist, this step is omitted which improves
#' the runtime of the algorithm.
#'
#' @param dataSet The data set.
#' @param weightMatrix The initial weight matrix (also known as codebook matrix). A possible
#' initialization is provided with the function \code{som.init.extended}. Note that the
#' weight matrix must have N rows where N is a squared number because this SOM algorithm
#' arranges the N codebook neurons in a two-dimensional quadratic grid.
#' @param oldColumns A boolean vector specifying the columns of the data set which were already
#' available before the data set has been extended. In other words, the SOM algorithm only
#' uses these columns for the calculation of Best Matching Units while the other other columns
#' are ignored during this step, but still modified during the update of the weight matrix
#' (codebook matrix).
#' @param rlen A vector with two integers specifying how many cycles are used for the two training
#' steps. Default value is \code{(2,10)}. If only one value x is provided, it will be
#' interpreted as \code{(x, 10*x)}. This is based on the \code{som} package written by Jun Yan.
#' @param initLearnRate A vector with two numbers specifying the initial learn rate for the
#' two training steps. The default is \code{(0.05,0.02)}. If only one value \code{x} given, it will be
#' interpreted as \code{(x, x/2.0)}.
#' This is based on the \code{som} package written by Jun Yan.
#' @param initRadius A vector with two numbers specifying the initial radii for the
#' gaussian neighborhood function during the two training steps.
#' The default is \code{(somSize,min(somSize,3))}, where somSize refers to the size of the
#' quadratic grid which is used for the codebook neurons (see the argument \code{weightMatrix}.
#' If only one value \code{x} given, it will be interpreted as \code{(x, max(x,2))}.
#' This is based on the \code{som} package written by Jun Yan.
#' @param radiusReduction A number specifying how the radius for the gaussian neighborhood function
#' is reduced during each parameter update (see also \code{updateParametersPerEpoch}).
#' @param learnRateReduction A number specifying how the radius for the gaussian neighborhood function
#' is reduced during each parameter update (see also \code{updateParametersPerEpoch}).
#' @param normType This must be either 1 or 2. It specifies how the distance between neurons
#' in the quadratic grid is calculated. The value 1 uses the 1-norm (absolute value) and leads
#' to rectangular structures in the resulting SOM while the value 2 uses the 2-norm (root of the
#' sum of squares, also known as euclidian norm) which leads to circular structures.
#' @param sampling A non-negative integer specifying how the data set is run through during
#' a training cycle. The value 0 makes the algorithm run through the data set without any
#' changes. The value 1 makes it use a random order while any value K greater than 1
#' makes it randomly select K rows from the data sets (there it is possible that the
#' same row is selected multiple times)
#' @param naExist A boolean value indicating whether NAs are present. If the argument
#' \code{naExist} is set to \code{FALSE}, the first 100 lines of the data set will be
#' scanned for NA values. Depending on whether NA values are found slightly different
#' SOM algorithms are executed:
#' If NA values exist, the algorithm will ignore these values during the calculation of the
#' Best Matching Unit (BMU). If no NA values exist, this step is omitted which improves
#' the runtime of the algorithm.
#' @param updateParametersPerEpoch A boolean value specifying when the learning rate and the
#' radius are updated during the SOM training. If it is set to \code{TRUE}, the update is done
#' after the algorithm went through the data set (or the sampled rows if \code{sampling} > 1).
#' The \code{som} algorithm written bei Jun Yan updates the learn rate and radius after every row.
#' This behavior is replicated by setting \code{updateParametersPerEpoch} to \code{FALSE}.
#' @return A weight matrix (codebook matrix) after the training has been completed.
#' @export
#' @examples
#' # generate data and initialize weight matrix
#' dataSet <- matrix(as.numeric(1:400),ncol=2)
#' weightMatrix <- som.init.extended(dataSet, somSize=2, oldColumns=c(TRUE,TRUE))
#'
#' # apply the algorithm
#' result <- somCheckNa(dataSet, weightMatrix, oldColumns=c(TRUE,TRUE))
somCheckNa <- function(dataSet, weightMatrix, oldColumns, rlen = as.integer( c(0)), initLearnRate = as.numeric( c(0)), initRadius = as.numeric( c(0.0)), radiusReduction = -1.0, learnRateReduction = 0.0, normType = 2L, sampling = 0L, naExist = FALSE, updateParametersPerEpoch = TRUE) {
    .Call('xSom_somCheckNa', PACKAGE = 'xSom', dataSet, weightMatrix, oldColumns, rlen, initLearnRate, initRadius, radiusReduction, learnRateReduction, normType, sampling, naExist, updateParametersPerEpoch)
}

#' A SOM algorithm that handles NA values.
#'
#' This function is identical to \code{somCheckNa}, but returns a list containing the following
#' elements: (insert here)
#'
#' ...
#'
#' @inheritParams somCheckNa
#' @return A list described above.
#' //@export
#' @examples
#' # generate data and initialize weight matrix
#' dataSet <- matrix(as.numeric(1:400),ncol=2)
#' weightMatrix <- som.init.extended(dataSet, somSize=2, oldColumns=c(TRUE,TRUE))
#'
#' # apply the algorithm
#' result <- somWithMapping(dataSet, weightMatrix, oldColumns=c(TRUE,TRUE))
somWithMapping <- function(dataSet, weightMatrix, oldColumns, rlen = as.integer( c(0)), initLearnRate = as.numeric( c(0)), initRadius = as.numeric( c(0.0)), radiusReduction = -1.0, learnRateReduction = 0.0, normType = 2L, sampling = 0L, naExist = TRUE, updateParametersPerEpoch = TRUE) {
    .Call('xSom_somWithMapping', PACKAGE = 'xSom', dataSet, weightMatrix, oldColumns, rlen, initLearnRate, initRadius, radiusReduction, learnRateReduction, normType, sampling, naExist, updateParametersPerEpoch)
}

rearrangeNeuronCoordinates <- function(neuronCoordinates, somSize) {
    .Call('xSom_rearrangeNeuronCoordinates', PACKAGE = 'xSom', neuronCoordinates, somSize)
}

